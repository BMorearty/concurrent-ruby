<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>
  Class: Concurrent::ThreadPoolExecutor
  
    &mdash; Concurrent
  
</title>

  <link rel="stylesheet" href="../css/style.css" type="text/css" charset="utf-8" />

  <link rel="stylesheet" href="../css/common.css" type="text/css" charset="utf-8" />

<script type="text/javascript" charset="utf-8">
  hasFrames = window.top.frames.main ? true : false;
  relpath = '../';
  framesUrl = "../frames.html#!Concurrent/ThreadPoolExecutor.html";
</script>


  <script type="text/javascript" charset="utf-8" src="../js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="../js/app.js"></script>


  </head>
  <body>
    <div id="header">
      <div id="menu">
  
    <a href="../_index.html">Index (T)</a> &raquo;
    <span class='title'><span class='object_link'><a href="../Concurrent.html" title="Concurrent (module)">Concurrent</a></span></span>
     &raquo; 
    <span class="title">ThreadPoolExecutor</span>
  

  <div class="noframes"><span class="title">(</span><a href="." target="_top">no frames</a><span class="title">)</span></div>
</div>

      <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="../class_list.html">
      Class List
    </a>
  
    <a class="full_list_link" id="method_list_link"
        href="../method_list.html">
      Method List
    </a>
  
    <a class="full_list_link" id="file_list_link"
        href="../file_list.html">
      File List
    </a>
  
</div>
      <div class="clear"></div>
    </div>

    <iframe id="search_frame"></iframe>

    <div id="content"><h1>Class: Concurrent::ThreadPoolExecutor
  
  
  
</h1>

<dl class="box">
  
    <dt class="r1">Inherits:</dt>
    <dd class="r1">
      <span class="inheritName"><span class='object_link'><a href="RubyThreadPoolExecutor.html" title="Concurrent::RubyThreadPoolExecutor (class)">RubyThreadPoolExecutor</a></span></span>
      
        <ul class="fullTree">
          <li>Object</li>
          
            <li class="next"><span class='object_link'><a href="RubyThreadPoolExecutor.html" title="Concurrent::RubyThreadPoolExecutor (class)">RubyThreadPoolExecutor</a></span></li>
          
            <li class="next">Concurrent::ThreadPoolExecutor</li>
          
        </ul>
        <a href="#" class="inheritanceTree">show all</a>
      
      </dd>
    
  
  
    
  
    
  
  
  
    <dt class="r2 last">Defined in:</dt>
    <dd class="r2 last">lib/concurrent/executor/thread_pool_executor.rb<span class="defines">,<br />
  lib/concurrent/executor/thread_pool_executor.rb</span>
</dd>
  
</dl>
<div class="clear"></div>

<h2>Overview</h2><div class="docstring">
  <div class="discussion">
    
  <div class="note notetag">
    <strong>Note:</strong>
    <div class='inline'><p>When running on the JVM (JRuby) this class will inherit from <code>JavaThreadPoolExecutor</code>.
On all other platforms it will inherit from <code>RubyThreadPoolExecutor</code>.</p>
</div>
  </div>

<p>An abstraction composed of one or more threads and a task queue. Tasks
(blocks or <code>proc</code> objects) are submit to the pool and added to the queue.
The threads in the pool remove the tasks and execute them in the order
they were received. When there are more tasks queued than there are
threads to execute them the pool will create new threads, up to the
configured maximum. Similarly, threads that are idle for too long will
be garbage collected, down to the configured minimum options. Should a
thread crash it, too, will be garbage collected.</p>

<p><code>ThreadPoolExecutor</code> is based on the Java class of the same name. From
the official Java documentationa;</p>

<blockquote>
<p>Thread pools address two different problems: they usually provide
improved performance when executing large numbers of asynchronous tasks,
due to reduced per-task invocation overhead, and they provide a means
of bounding and managing the resources, including threads, consumed
when executing a collection of tasks. Each ThreadPoolExecutor also
maintains some basic statistics, such as the number of completed tasks.</p>

<p>To be useful across a wide range of contexts, this class provides many
adjustable parameters and extensibility hooks. However, programmers are
urged to use the more convenient Executors factory methods
<a href="unbounded%20thread%20pool,%20with%20automatic%20thread%20reclamation">CachedThreadPool</a>,
<a href="fixed%20size%20thread%20pool">FixedThreadPool</a> and <a href="single%0Abackground%20thread">SingleThreadExecutor</a>, that preconfigure settings for the most common usage
scenarios.</p>
</blockquote>

<p>Thread pools support several configuration options:</p>

<ul>
<li><code>max_threads</code>: The maximum number of threads that may be created in the pool.</li>
<li><code>min_threads</code>: The minimum number of threads that may be retained in the pool.</li>
<li><code>idletime</code>: The number of seconds that a thread may be idle before being reclaimed.</li>
<li><code>max_queue</code>: The maximum number of tasks that may be waiting in the work queue at
any one time. When the queue size reaches <code>max_queue</code> subsequent tasks will be
rejected in accordance with the configured <code>overflow_policy</code>.</li>
<li><code>overflow_policy</code>: The policy defining how rejected tasks are handled.    #</li>
</ul>

<p>Three overflow policies are supported:</p>

<ul>
<li><code>:abort</code>: Raise a <code>RejectedExecutionError</code> exception and discard the task.</li>
<li><code>:discard</code>: Silently discard the task and return <code>nil</code> as the task result.</li>
<li><code>:caller_runs</code>: Execute the task on the calling thread.</li>
</ul>

<p><h1>Thread Pools</h1>

<p>A Thread Pool is an abstraction that you can give a unit of work to, and the work will be executed by one of possibly several threads in the pool. One motivation for using thread pools is the overhead of creating and destroying threads. Creating a pool of reusable worker threads then repeatedly re-using threads from the pool can have huge performace benefits for a long-running application like a service.</p>

<p><code>concurrent-ruby</code> also offers some higher level abstractions than thread pools. For many problems, you will be better served by using one of these -- if you are thinking of using a thread pool, we especially recommend you look at and understand <a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Future.html">Future</a>s before deciding to use thread pools directly instead.  Futures are implemented using thread pools, but offer a higher level abstraction.</p>

<p>But there are some problems for which directly using a thread pool is an appropriate solution. Or, you may wish to make your own thread pool to run Futures on, to be separate or have different characteristics than the global thread pool that Futures run on by default.</p>

<p>Thread pools are considered &#39;executors&#39; -- an object you can give a unit of work to, to have it exeucted.  In fact, thread pools are the main kind of executor you will see, others are mainly for testing or odd edge cases. In some documentation or source code you&#39;ll see reference to an &#39;executor&#39; -- this is commonly a thread pool, or else something similar that executes units of work (usually supplied as ruby blocks).</p>

<h2>FixedThreadPool</h2>

<p>A <a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/FixedThreadPool.html">FixedThreadPool</a> contains a fixed number of threads. When you give a unit if work to it, an available thread will be used to execute.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool'>pool</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>FixedThreadPool</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='int'>5</span><span class='rparen'>)</span> <span class='comment'># 5 threads
</span><span class='id identifier rubyid_pool'>pool</span><span class='period'>.</span><span class='id identifier rubyid_post'>post</span> <span class='kw'>do</span>
   <span class='comment'># some parallel work
</span><span class='kw'>end</span>
<span class='comment'># As with all thread pools, execution resumes immediately here in the caller thread,
</span><span class='comment'># while work is concurrently being done in the thread pool, at some possibly future point.
</span></code></pre>

<p>What happens if you post new work when all (eg) 5 threads are currently busy? It will be added to a queue, and executed when a thread becomes available.  In a <code>FixedThreadPool</code>, if you post work to the pool much faster than the work can be completed, the queue may grow without bounds, as the work piles up in the holding queue, using up memory without bounds.  To limit the queue and apply some form of &#39;back pressure&#39; instead, you can use the more configurable <code>ThreadPoolExecutor</code> (See below).</p>

<p>If you&#39;d like to base the number of threads in the pool on the number of processors available, your code can consult <a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/ProcessorCounter.html#processor_count-instance_method">Concurrent.processor_count</a>.</p>

<p>The <code>FixedThreadPool</code> is based on the semantics used in Java for <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newFixedThreadPool(int)">java.util.concurrent.Executors.newFixedThreadPool(int nThreads)</a></p>

<h2>CachedThreadPool</h2>

<p>A <a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/CachedThreadPool.html">CachedThreadPool</a> will create as many threads as neccesary for work posted to it. If you post work to a <code>CachedThreadPool</code> when all it&#39;s existing threads are busy, it will create a new thread to execute that work, and then keep that thread cached for future work. Cached threads are reclaimed (destroyed) after they are idle for a while.</p>

<p>CachedThreadPools typically improve the performance of programs that execute many short-lived asynchronous tasks.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool'>pool</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>CachedThreadPool</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>
<span class='id identifier rubyid_pool'>pool</span><span class='period'>.</span><span class='id identifier rubyid_post'>post</span> <span class='kw'>do</span>
  <span class='comment'># some parallel work
</span><span class='kw'>end</span>
</code></pre>

<p>The behavior of <code>CachedThreadPool</code> is based on Java&#39;s <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html#newCachedThreadPool()">java.util.concurrent.Executors.newCachedThreadPool()</a></p>

<p>If you&#39;d like to configure a maximum number of threads, you can use the more general configurable <code>ThreadPoolExecutor</code>.</p>

<h2>ThreadPoolExecutor</h2>

<p>A <a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a> is a general-purpose thread pool that can be configured to have various behaviors.</p>

<p>The <code>CachedThreadPool</code> and <code>FixedThreadPool</code> are simply <code>ThreadPoolExecutor</code>s with certain configuration pre-determined. For instance, to create a <code>ThreadPoolExecutor</code> that works just like a <code>FixedThreadPool.new 5</code>, you could:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool'>pool</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>ThreadPoolExecutor</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
   <span class='label'>min_threads:</span> <span class='int'>5</span><span class='comma'>,</span>
   <span class='label'>max_threads:</span> <span class='int'>5</span><span class='comma'>,</span>
   <span class='label'>max_queue:</span> <span class='int'>0</span> <span class='comment'># unbounded work queue
</span><span class='rparen'>)</span>
</code></pre>

<p>If you want to provide a maximum queue size, you may also consider the <code>overflow_policy</code> -- what will happen if work is posted to a pool when the queue of waiting work has reached the maximum size? Available policies:</p>

<ul>
<li>abort: Raise a <code>Concurrent::RejectedExecutionError</code> exception and discard the task. (default policy)</li>
<li>discard: Silently discard the task and return nil as the task result.</li>
<li>caller_runs: The work will be executed in the thread of the caller, instead of being given to another thread in the pool</li>
</ul>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool'>pool</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>ThreadPoolExecutor</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
   <span class='label'>min_threads:</span> <span class='int'>5</span><span class='comma'>,</span>
   <span class='label'>max_threads:</span> <span class='int'>5</span><span class='comma'>,</span>
   <span class='label'>max_queue:</span> <span class='int'>100</span><span class='comma'>,</span>
   <span class='label'>overflow_policy:</span> <span class='symbol'>:caller_runs</span>
<span class='rparen'>)</span>
</code></pre>

<p>Similarly, you can create something similar to a <code>CachedThreadPool</code>, but with a maximum number of threads. With an unbounded queue:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool'>pool</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>ThreadPoolExecutor</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
   <span class='label'>min_threads:</span> <span class='int'>3</span><span class='comma'>,</span> <span class='comment'># create 3 threads at startup
</span>   <span class='label'>max_threads:</span> <span class='int'>10</span><span class='comma'>,</span> <span class='comment'># create at most 10 threads
</span>   <span class='label'>max_queue:</span> <span class='int'>0</span><span class='comma'>,</span> <span class='comment'># unbounded queue of work waiting for an available thread
</span><span class='rparen'>)</span>
</code></pre>

<p>Or, with a variable number of threads like a CachedThreadPool, but with a bounded queue and an overflow_policy:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool'>pool</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>ThreadPoolExecutor</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
   <span class='label'>min_threads:</span> <span class='int'>3</span><span class='comma'>,</span> <span class='comment'># create 3 threads at startup
</span>   <span class='label'>max_threads:</span> <span class='int'>10</span><span class='comma'>,</span> <span class='comment'># create at most 10 threads
</span>   <span class='label'>max_queue:</span> <span class='int'>100</span><span class='comma'>,</span> <span class='comment'># at most 100 jobs waiting in the queue,
</span>   <span class='label'>overflow_policy:</span> <span class='symbol'>:abort</span>
<span class='rparen'>)</span>
</code></pre>

<p>ThreadPoolExecutors with <code>min_threads</code> and <code>max_threads</code> set to different values will ordinarily reclaim idle threads.  You can supply an <code>idletime</code> argument, number of seconds that a thread may be idle before being reclaimed. The default is 60 seconds.</p>

<p><code>concurrent-ruby</code> thread pools are based on designs from <code>java.util.concurrent</code> --  a well-designed, stable, scalable, and battle-tested concurrency library. The <code>ThreadPoolExecutor</code> is based on Java <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ThreadPoolExecutor.html">java.util.concurrent.ThreadPoolExecutor</a>, and is in fact implemented with a Java ThreadPoolExecutor when running under JRuby. For more information on the design and concepts, you may find the Java documentation helpful:</p>

<ul>
<li><a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html">http://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html</a></li>
<li><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html">http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html</a></li>
<li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html</a></li>
</ul>

<h2>Thread Pool Status and Shutdown</h2>

<p>A running thread pool can be shutdown in an orderly or disruptive manner. Once a thread pool has been shutdown it cannot be started again.</p>

<p>The <code>shutdown</code> method can be used to initiate an orderly shutdown of the thread pool. All new post calls will reject the given block and immediately return false. Threads in the pool will continue to process all in-progress work and will process all tasks still in the queue.</p>

<p>The <code>kill</code> method can be used to immediately shutdown the pool. All new post calls will reject the given block and immediately return false. Ruby&#39;s Thread.kill will be called on all threads in the pool, aborting all in-progress work. Tasks in the queue will be discarded.</p>

<p>The method <code>wait_for_termination</code> can be used to block and wait for pool shutdown to complete. This is useful when shutting down an application and ensuring the app doesn&#39;t exit before pool processing is complete. The method wait_for_termination will block for a maximum of the given number of seconds then return true if shutdown completed successfully or false. When the timeout value is nil the call will block indefinitely. Calling wait_for_termination on a stopped thread pool will immediately return true.</p>

<pre class="code ruby"><code class="ruby"><span class='comment'># tell the pool to shutdown in an orderly fashion, allowing in progress work to complete
</span><span class='id identifier rubyid_pool'>pool</span><span class='period'>.</span><span class='id identifier rubyid_shutdown'>shutdown</span>
<span class='comment'># now wait for all work to complete, wait as long as it takes
</span><span class='id identifier rubyid_pool'>pool</span><span class='period'>.</span><span class='id identifier rubyid_wait_for_termination'>wait_for_termination</span>
</code></pre>

<p>You can check for current pool status:</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool'>pool</span><span class='period'>.</span><span class='id identifier rubyid_running?'>running?</span>
<span class='id identifier rubyid_pool'>pool</span><span class='period'>.</span><span class='id identifier rubyid_shuttingdown?'>shuttingdown?</span> <span class='comment'># in process of shutting down, can&#39;t take any more work
</span><span class='id identifier rubyid_pool'>pool</span><span class='period'>.</span><span class='id identifier rubyid_shutdown?'>shutdown?</span> <span class='comment'># it&#39;s done
</span></code></pre>

<p>The <code>shutdown?</code> method will return true for a stopped pool, regardless of whether the pool was stopped with <code>shutdown</code> or <code>kill</code>.</p>

<h2>Other Executors</h2>

<p>There are several other thread pools and executors in the <code>concurrent-ruby</code> library. See the API documentation for more information:</p>

<ul>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/CachedThreadPool.html">CachedThreadPool</a></li>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/FixedThreadPool.html">FixedThreadPool</a></li>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/ImmediateExecutor.html">ImmediateExecutor</a></li>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/PerThreadExecutor.html">PerThreadExecutor</a></li>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/SafeTaskExecutor.html">SafeTaskExecutor</a></li>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/SerializedExecution.html">SerializedExecution</a></li>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/SerializedExecutionDelegator.html">SerializedExecutionDelegator</a></li>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/SingleThreadExecutor.html">SingleThreadExecutor</a></li>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a></li>
<li><a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/TimerSet.html">TimerSet</a></li>
</ul>

<h2>Global Thread Pools</h2>

<p>Concurrent Ruby provides several global thread pools. Higher-level abstractions use global thread pools, by default, for running asynchronous operations without creating new threads more often than necessary. These executors are lazy-loaded so they do not create overhead when not needed. The global executors may also be accessed directly if desired. For more information regarding the global thread pools and their configuration, refer to the <a href="http://ruby-concurrency.github.io/concurrent-ruby/Concurrent/Configuration.html">API documentation</a>.</p>

<p>When using a higher-level abstraction, which ordinarily uses a global thread pool, you may wish to instead supply your own thread pool, for separation of work, or to control the thread pool behavior with configuration.</p>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_pool'>pool</span> <span class='op'>=</span> <span class='const'>Concurrent</span><span class='op'>::</span><span class='const'>ThreadPoolExecutor</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span>
  <span class='symbol'>:min_threads</span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='int'>2</span><span class='comma'>,</span> <span class='const'>Concurrent</span><span class='period'>.</span><span class='id identifier rubyid_processor_count'>processor_count</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_max'>max</span><span class='comma'>,</span>
  <span class='symbol'>:max_threads</span> <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='int'>2</span><span class='comma'>,</span> <span class='const'>Concurrent</span><span class='period'>.</span><span class='id identifier rubyid_processor_count'>processor_count</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_max'>max</span><span class='comma'>,</span>
  <span class='symbol'>:max_queue</span>   <span class='op'>=&gt;</span> <span class='lbracket'>[</span><span class='int'>2</span><span class='comma'>,</span> <span class='const'>Concurrent</span><span class='period'>.</span><span class='id identifier rubyid_processor_count'>processor_count</span><span class='rbracket'>]</span><span class='period'>.</span><span class='id identifier rubyid_max'>max</span> <span class='op'>*</span> <span class='int'>5</span><span class='comma'>,</span>
  <span class='symbol'>:overflow_policy</span> <span class='op'>=&gt;</span> <span class='symbol'>:caller_runs</span>
<span class='rparen'>)</span>

<span class='id identifier rubyid_future'>future</span> <span class='op'>=</span> <span class='const'>Future</span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span><span class='lparen'>(</span><span class='symbol'>:executor</span> <span class='op'>=&gt;</span> <span class='id identifier rubyid_pool'>pool</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span> <span class='kw'>do</span>
   <span class='comment'>#work
</span><span class='kw'>end</span>
</code></pre>
</p>


  </div>
</div>
<div class="tags">
  

  <p class="tag_title">See Also:</p>
  <ul class="see">
    
      <li><span class='object_link'><a href="RubyThreadPoolExecutor.html" title="Concurrent::RubyThreadPoolExecutor (class)">RubyThreadPoolExecutor</a></span></li>
    
      <li><span class='object_link'><a href="JavaThreadPoolExecutor.html" title="Concurrent::JavaThreadPoolExecutor (class)">JavaThreadPoolExecutor</a></span></li>
    
      <li><a href="http://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html" target="_parent" title="http://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html">http://docs.oracle.com/javase/tutorial/essential/concurrency/pools.html</a></li>
    
      <li><a href="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html" target="_parent" title="http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html">http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executors.html</a></li>
    
      <li><a href="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html" target="_parent" title="http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">http://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html</a></li>
    
  </ul>

</div>
  <h2>Constant Summary</h2>
  




  <h2>Instance Attribute Summary <small>(<a href="#" class="summary_toggle">collapse</a>)</small></h2>
  <ul class="summary">
    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#completed_task_count-instance_method" title="#completed_task_count (instance method)">- (Object) <strong>completed_task_count</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      inherited
      from <span class='object_link'><a href="RubyThreadPoolExecutor.html#completed_task_count-instance_method" title="Concurrent::RubyThreadPoolExecutor#completed_task_count (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The number of tasks that have been completed by the pool since construction.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#idletime-instance_method" title="#idletime (instance method)">- (Object) <strong>idletime</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      inherited
      from <span class='object_link'><a href="RubyThreadPoolExecutor.html#idletime-instance_method" title="Concurrent::RubyThreadPoolExecutor#idletime (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The number of seconds that a thread may be idle before being reclaimed.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#largest_length-instance_method" title="#largest_length (instance method)">- (Object) <strong>largest_length</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      inherited
      from <span class='object_link'><a href="RubyThreadPoolExecutor.html#largest_length-instance_method" title="Concurrent::RubyThreadPoolExecutor#largest_length (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The largest number of threads that have been created in the pool since construction.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#max_length-instance_method" title="#max_length (instance method)">- (Object) <strong>max_length</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      inherited
      from <span class='object_link'><a href="RubyThreadPoolExecutor.html#max_length-instance_method" title="Concurrent::RubyThreadPoolExecutor#max_length (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The maximum number of threads that may be created in the pool.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#max_queue-instance_method" title="#max_queue (instance method)">- (Object) <strong>max_queue</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      inherited
      from <span class='object_link'><a href="RubyThreadPoolExecutor.html#max_queue-instance_method" title="Concurrent::RubyThreadPoolExecutor#max_queue (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The maximum number of tasks that may be waiting in the work queue at any one time.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#min_length-instance_method" title="#min_length (instance method)">- (Object) <strong>min_length</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      inherited
      from <span class='object_link'><a href="RubyThreadPoolExecutor.html#min_length-instance_method" title="Concurrent::RubyThreadPoolExecutor#min_length (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The minimum number of threads that may be retained in the pool.</p>
</div></span>
  
</li>

    
      <li class="protected ">
  <span class="summary_signature">
    
      <a href="#mutex-instance_method" title="#mutex (instance method)">- (Object) <strong>mutex</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      included
      from <span class='object_link'><a href="RubyExecutor.html#mutex-instance_method" title="Concurrent::RubyExecutor#mutex (method)">RubyExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  <span class="note title protected">protected</span>
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns the value of attribute mutex.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#overflow_policy-instance_method" title="#overflow_policy (instance method)">- (Object) <strong>overflow_policy</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      inherited
      from <span class='object_link'><a href="RubyThreadPoolExecutor.html#overflow_policy-instance_method" title="Concurrent::RubyThreadPoolExecutor#overflow_policy (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The policy defining how rejected tasks (tasks received once the queue size reaches the configured <code>max_queue</code>) are handled.</p>
</div></span>
  
</li>

    
      <li class="public ">
  <span class="summary_signature">
    
      <a href="#scheduled_task_count-instance_method" title="#scheduled_task_count (instance method)">- (Object) <strong>scheduled_task_count</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      inherited
      from <span class='object_link'><a href="RubyThreadPoolExecutor.html#scheduled_task_count-instance_method" title="Concurrent::RubyThreadPoolExecutor#scheduled_task_count (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>The number of tasks that have been scheduled for execution on the pool since construction.</p>
</div></span>
  
</li>

    
      <li class="protected ">
  <span class="summary_signature">
    
      <a href="#stop_event-instance_method" title="#stop_event (instance method)">- (Object) <strong>stop_event</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      included
      from <span class='object_link'><a href="RubyExecutor.html#stop_event-instance_method" title="Concurrent::RubyExecutor#stop_event (method)">RubyExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  <span class="note title protected">protected</span>
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns the value of attribute stop_event.</p>
</div></span>
  
</li>

    
      <li class="protected ">
  <span class="summary_signature">
    
      <a href="#stopped_event-instance_method" title="#stopped_event (instance method)">- (Object) <strong>stopped_event</strong> </a>
    

    
  </span>
  
    <span class="note title not_defined_here">
      included
      from <span class='object_link'><a href="RubyExecutor.html#stopped_event-instance_method" title="Concurrent::RubyExecutor#stopped_event (method)">RubyExecutor</a></span>
    </span>
  
  
  
    
      <span class="note title readonly">readonly</span>
    
    
  
  <span class="note title protected">protected</span>
  
  
  

  
    <span class="summary_desc"><div class='inline'><p>Returns the value of attribute stopped_event.</p>
</div></span>
  
</li>

    
  </ul>





  
  
  
  
  
  
  
  
  <div id="constructor_details" class="method_details_list">
  <h2>Constructor Details</h2>
  
    <p class="notice">This class inherits a constructor from <span class='object_link'><a href="RubyThreadPoolExecutor.html#initialize-instance_method" title="Concurrent::RubyThreadPoolExecutor#initialize (method)">Concurrent::RubyThreadPoolExecutor</a></span></p>
  
</div>

  <div id="instance_attr_details" class="attr_details">
    <h2>Instance Attribute Details</h2>
    
      
      <span id=""></span>
      <div class="method_details first">
  <h3 class="signature first" id="completed_task_count-instance_method">
  
    - (<tt>Object</tt>) <strong>completed_task_count</strong>  <span class="extras">(readonly)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in class
        <span class='object_link'><a href="RubyThreadPoolExecutor.html#completed_task_count-instance_method" title="Concurrent::RubyThreadPoolExecutor#completed_task_count (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>The number of tasks that have been completed by the pool since construction.</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="idletime-instance_method">
  
    - (<tt>Object</tt>) <strong>idletime</strong>  <span class="extras">(readonly)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in class
        <span class='object_link'><a href="RubyThreadPoolExecutor.html#idletime-instance_method" title="Concurrent::RubyThreadPoolExecutor#idletime (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>The number of seconds that a thread may be idle before being reclaimed.</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="largest_length-instance_method">
  
    - (<tt>Object</tt>) <strong>largest_length</strong>  <span class="extras">(readonly)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in class
        <span class='object_link'><a href="RubyThreadPoolExecutor.html#largest_length-instance_method" title="Concurrent::RubyThreadPoolExecutor#largest_length (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>The largest number of threads that have been created in the pool since construction.</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="max_length-instance_method">
  
    - (<tt>Object</tt>) <strong>max_length</strong>  <span class="extras">(readonly)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in class
        <span class='object_link'><a href="RubyThreadPoolExecutor.html#max_length-instance_method" title="Concurrent::RubyThreadPoolExecutor#max_length (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>The maximum number of threads that may be created in the pool.</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="max_queue-instance_method">
  
    - (<tt>Object</tt>) <strong>max_queue</strong>  <span class="extras">(readonly)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in class
        <span class='object_link'><a href="RubyThreadPoolExecutor.html#max_queue-instance_method" title="Concurrent::RubyThreadPoolExecutor#max_queue (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>The maximum number of tasks that may be waiting in the work queue at any one time.
When the queue size reaches <code>max_queue</code> subsequent tasks will be rejected in
accordance with the configured <code>overflow_policy</code>.</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="min_length-instance_method">
  
    - (<tt>Object</tt>) <strong>min_length</strong>  <span class="extras">(readonly)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in class
        <span class='object_link'><a href="RubyThreadPoolExecutor.html#min_length-instance_method" title="Concurrent::RubyThreadPoolExecutor#min_length (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>The minimum number of threads that may be retained in the pool.</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="mutex-instance_method">
  
    - (<tt>Object</tt>) <strong>mutex</strong>  <span class="extras">(readonly, protected)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in module
        <span class='object_link'><a href="RubyExecutor.html#mutex-instance_method" title="Concurrent::RubyExecutor#mutex (method)">RubyExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns the value of attribute mutex</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="overflow_policy-instance_method">
  
    - (<tt>Object</tt>) <strong>overflow_policy</strong>  <span class="extras">(readonly)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in class
        <span class='object_link'><a href="RubyThreadPoolExecutor.html#overflow_policy-instance_method" title="Concurrent::RubyThreadPoolExecutor#overflow_policy (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>The policy defining how rejected tasks (tasks received once the queue size reaches
the configured <code>max_queue</code>) are handled. Must be one of the values specified in
<code>OVERFLOW_POLICIES</code>.</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="scheduled_task_count-instance_method">
  
    - (<tt>Object</tt>) <strong>scheduled_task_count</strong>  <span class="extras">(readonly)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in class
        <span class='object_link'><a href="RubyThreadPoolExecutor.html#scheduled_task_count-instance_method" title="Concurrent::RubyThreadPoolExecutor#scheduled_task_count (method)">RubyThreadPoolExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>The number of tasks that have been scheduled for execution on the pool since construction.</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="stop_event-instance_method">
  
    - (<tt>Object</tt>) <strong>stop_event</strong>  <span class="extras">(readonly, protected)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in module
        <span class='object_link'><a href="RubyExecutor.html#stop_event-instance_method" title="Concurrent::RubyExecutor#stop_event (method)">RubyExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns the value of attribute stop_event</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
      
      <span id=""></span>
      <div class="method_details ">
  <h3 class="signature " id="stopped_event-instance_method">
  
    - (<tt>Object</tt>) <strong>stopped_event</strong>  <span class="extras">(readonly, protected)</span>
  

  

  
    <span class="not_defined_here">
      Originally defined in module
        <span class='object_link'><a href="RubyExecutor.html#stopped_event-instance_method" title="Concurrent::RubyExecutor#stopped_event (method)">RubyExecutor</a></span>
    </span>
  
</h3><div class="docstring">
  <div class="discussion">
    <p>Returns the value of attribute stopped_event</p>


  </div>
</div>
<div class="tags">
  

</div>
</div>
    
  </div>


</div>

    <div id="footer">
  Generated on Wed Nov 26 09:45:07 2014 by
  <a href="http://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.8.7.6 (ruby-2.1.5).
</div>

<script>
//  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
//    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
//      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
//  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
//
//  ga('create', 'UA-4005004-8', 'pitr.ch');
//  ga('send', 'pageview');
</script>

  </body>
</html>